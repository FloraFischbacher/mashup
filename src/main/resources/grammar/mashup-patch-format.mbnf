# This is a sketch of the way in which the invoke syntax could work.

# TODO define CAPTURE WITHIN syntax (NOTE: it's going to be different!!)
# TODO define LISTEN TO syntax
# TODO define file-function reference syntax "func" OF "file"
# TODO define alias syntax (low-hanging fruit)
# TODO define dependency syntax

grammar = "";

statement = definition (script-patch) 0/[soft-deps firm-deps hard-deps];

script-patch = target source script-method *1(aliases);

target = "";
source = "";
script-method = "(" rule ")" 1*(conjunction "(" rule ")") *c-wsp;

conjunction = *c-wsp ("OR" | "AND") *c-wsp;

rule = *c-wsp q-rule *c-wsp  # meaning "quantifiable position"
     | *c-wsp s-rule *c-wsp; # meaning "single-position"
     | *c-wsp r-rule *c-wsp 
     # "return rule", because `RETURN` patches are only written with `BEFORE`.

s-rule   = s-offset s-method;
s-offset = *c-wsp "AT" *c-wsp;
s-method = ("HEAD" | "TAIL") *c-wsp;

r-rule = "BEFORE" *c-wsp ((quantifier "RETURN") | (*c-wsp "RETURN" q-ordinal-set));

q-rule = q-offset q-target;

q-offset = *c-wsp ("BEFORE" | "AFTER") *c-wsp
         | "(" q-offset ")" conjunction "(" q-offset ")" *c-wsp;
         # This allows "(BEFORE) OR (BEFORE)" but... why would you??

q-target = access | assign | declare | invoke | line

access  = ((quantifier "ACCESS") | (*c-wsp "ACCESS" q-ordinal-set)) "OF" gd-var;
assign  = ((quantifier "ASSIGN") | (*c-wsp "ASSIGN" q-ordinal-set)) "OF" gd-var;
declare = ((quantifier "DECLARE") | (*c-wsp "DECLARE" q-ordinal-set)) "OF" gd-var;
invoke  = ((quantifier "INVOKE") | (*c-wsp "INVOKE" q-ordinal-set)) "OF" gd-func;
line    = ((quantifier "LINE") | (*c-wsp "LINE" q-ordinal-set)) *c-wsp;

gd-var  = *c-wsp DQUOTE *GRAPH DQUOTE *c-wsp;
gd-func = *c-wsp DQUOTE *GRAPH DQUOTE *c-wsp;

quantifier = *c-wsp ("FIRST" | "LAST") *c-wsp *1(q-cardinal)
           | "(" quantifier ")" conjunction "(" quantifier ")" *c-wsp;

q-cardinal    = 1*DIGIT *c-wsp;
q-ordinal-set = *c-wsp 1*DIGIT *c-wsp *("," *c-wsp 1*DIGIT *c-wsp);
